/******************************************************************************

        Copyright (C) 2011 Atsuto Seko
                seko@cms.mtl.kyoto-u.ac.jp

        This program is free software; you can redistribute it and/or
        modify it under the terms of the GNU General Public License
        as published by the Free Software Foundation; either version 2
        of the License, or (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program; if not, write to
        the Free Software Foundation, Inc., 51 Franklin Street,
        Fifth Floor, Boston, MA 02110-1301, USA, or see
        http://www.gnu.org/copyleft/gpl.txt

	    Class for converting structure to POSCAR
	
*****************************************************************************/

#include <iostream>
#include <vector>

#include "getopt.h"

#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/io.hpp>

#include "parse_structure.h"

namespace ublas = boost::numeric::ublas;
typedef ublas::vector<double> dvector;
typedef ublas::matrix<double> dmatrix;

extern char *optarg;
extern int optind, opterr, optopt;

int main(int argc, char *argv[]){

    const char *file_name = NULL;

    int option;
    opterr = 0;
    while((option=getopt(argc,argv,"f:"))!=-1){
        switch( option ){
            case 'f' : file_name = optarg;
                       break;
        }
    }
    if (file_name == NULL){
        std::cerr << " Specify file name of structure (option -f)." 
            << std::endl;
        exit(8);
    }


    Parse_structure input(file_name);
    dmatrix axis(input.get_axis());
    std::vector<int> n_atoms(input.get_num_atoms());
    std::vector<dvector> position(input.get_position());

    double volume = input.get_volume();
    if (volume < 0){
        dmatrix new_axis(3,3);
        std::vector<dvector> new_position;
        for (int i = 0; i < 3; ++i){
            new_axis(i,0) = axis(i,1);
            new_axis(i,1) = axis(i,0);
            new_axis(i,2) = axis(i,2);
        }
        for (int i = 0; i < position.size(); ++i){
            dvector pos(3);
            pos(0) = position[i](1);
            pos(1) = position[i](0);
            pos(2) = position[i](2);
            new_position.push_back(pos);
        }
        axis = new_axis;
        position = new_position;
    }

    std::cout << "generated by clupan" << std::endl;
    std::cout << "1.0" << std::endl;
    std::cout.precision(10);
    std::cout.setf(std::ios::showpoint);
    for (int i = 0; i < axis.size2(); ++i){
        std::cout << "  ";
        for (int j = 0; j < axis.size1(); ++j){
            std::cout << axis(j,i) << "  ";
        }
        std::cout << std::endl;
    }

    std::cout << "  ";
    for (int i = 0; i < n_atoms.size(); ++i){
        std::cout << n_atoms[i] << " ";
    }
    std::cout << std::endl;
    std::cout << "Direct" << std::endl;

    for (int i = 0; i < position.size(); ++i){
        std::cout << "  ";
        for (int j = 0; j < position[i].size(); ++j){
            std::cout << position[i](j) << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
